''' =========================================================================================== '''
# BlueHat Flask Views
''' =========================================================================================== '''
# Imports
from app import app, models, socketio, login_manager, redis
from app.KalmanFilter import KalmanFilter
from app.models import *
from app import db
from env import *
from flask import render_template, redirect, url_for, request, abort
from flask import jsonify, session, g, make_response
from flask_socketio import SocketIO, Namespace, send, emit, disconnect
from datetime import datetime
from datetime import timedelta
from functools import update_wrapper
from box import Box
from sqlalchemy import *
from sqlalchemy.sql import func
from passlib.hash import sha256_crypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from flask_redis import Redis
import requests
import json
import jsonpickle
import time
import math

''' =========================================================================================== '''
# BlueHat Web Routes

login_manager.login_view = "index_view"

# Advertiser: (aa - Index i = 0), (bb - Index i = 1), (cc - Index i = 2)
# Observer: (1 - Index j = 0), (2 - Index j = 1), (3 - Index j = 2), (4 - Index j = 3), (5 - Index j = 4)
# kalmanFilterArr = [[KalmanFilter(processNoise=0.008, measurementNoise=3) for i in range(3)] for j in range(5)]
kalmanFilterB1 = KalmanFilter(processNoise=0.008, measurementNoise=3.5)
kalmanFilterC1 = KalmanFilter(processNoise=0.008, measurementNoise=3.5)
rssi_ref = -53.4

# PUT CONSTANT OBSERVER LOCATIONS COORDS HERE
DeviceID_List = ['bbbbbbbb', 'cccccccc']
ObserverLocation = [(0, 0), (0, 0), (0, 0), (0, 0)]

timePrev = 0

@login_manager.user_loader
def load_user(user_email):
    return Users.query.filter_by(email=user_email).first()

'''
Description: Render the index page here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/', methods=['GET'])
def index_view():
    return render_template('/home/index.html')

'''
Description: User registration
Input: Username, first name, last name, password, email
Return Type: HTML, 200 for success otherwise failure
'''
@app.route('/register', methods=['GET', 'POST'])
def register_user():
    username = request.form['username']
    firstName = request.form['firstName']
    lastName = request.form['lastName']
    email = request.form['email']
    password = sha256_crypt.hash(request.form['password'])
    registered = datetime.now()
    authenticated = True
    admin = False

    availableName = Users.query.filter_by(username=username).first()
    if availableName is None:
        user = Users(email, username, password, firstName, lastName, registered, authenticated, admin)
        db.session.add(user)
        db.session.commit()
        session['user'] = dict(email=email, id=None, admin=user.admin)
        login_user(user, remember=True)
        return redirect(url_for('dashboard_view'))
    else:
        return error_401(errCode="1", msg="Username already exists")

'''
Description: Post being sent from client side for login verification
Input: Username and password
Return Type: HTML, 200 for success otherwise failure
'''
@app.route('/login', methods=['GET', 'POST'])
def login():
    userByUsername = Users.query.filter_by(username=request.form['id']).first()
    userByEmail = Users.query.filter_by(email=request.form['id']).first()
    if userByUsername is not None:
        if sha256_crypt.verify(request.form['password'], userByUsername.password):
            session['user'] = dict(email=userByUsername.email, profile_url=None, id=None, access_token=None, admin=userByUsername.admin)
            userByUsername.authenticated = True
            db.session.add(userByUsername)
            db.session.commit()
            session['user'] = dict(email=userByUsername.email, id=None, admin=userByUsername.admin)
            login_user(userByUsername, remember=True)
            return redirect(url_for('dashboard_view'))
        else:
            return error_401(errCode="2", msg="Login failed")
    if userByEmail is not None:
        if sha256_crypt.verify(request.form['password'], userByEmail.password):
            session['user'] = dict(email=userByEmail.email, profile_url=None, id=None, access_token=None, admin=userByEmail.admin)
            userByEmail.authenticated = True
            db.session.add(userByEmail)
            db.session.commit()
            session['user'] = dict(type='fitquest', email=email, id=None, admin=userByEmail.admin)
            login_user(userByEmail, remember=True)
            return redirect(url_for('dashboard_view'))
        else:
            return error_401(errCode="2", msg="Login failed")
    return error_401(errCode="2", msg="Login failed")

'''
Description: Render the dashboard page view here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard', methods=['GET', 'POST'])
@login_required
def dashboard_view():
    if session['user']['admin']:
        admin = 1
    else:
        admin = 0
    return render_template('/home/dashboard.html', admin=admin)

'''
Description: Render the dashboard home page view here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard/home', methods=['GET', 'POST'])
@login_required
def dashboard_home_view():
    return render_template('/home/dashboard_home.html')

'''
Description: Render the dashboard profile page view here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard/profile', methods=['GET', 'POST'])
@login_required
def dashboard_profile_view():
    return render_template('/home/dashboard_profile.html')

'''
Description: Render the dashboard observers page view here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard/observers', methods=['GET', 'POST'])
@login_required
def dashboard_observers_view():
    return render_template('/home/dashboard_observers.html')

'''
Description: Render the dashboard advertisers page view here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard/advertisers', methods=['GET', 'POST'])
@login_required
def dashboard_advertisers_view():
    return render_template('/home/dashboard_advertisers.html')

'''
Description: Render the dashboard settings page view here from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard/settings', methods=['GET', 'POST'])
@login_required
def dashboard_settings_view():
    return render_template('/home/dashboard_settings.html')

'''
Description: Render the dashboard analytics page view from templates
Input: None
Return Type: HTML, a view generated by render_template()
'''
@app.route('/dashboard/analytics', methods=['GET', 'POST'])
@login_required
def dashboard_analytics_view():
    return render_template('/home/dashboard_analytics.html')

'''
Description: Pops user from the session, logging them out
Input: None
Return Type: Redirects user to login page
'''
@app.route('/logout')
@login_required
def dropsession():
    user = current_user
    user.authenticated = False
    db.session.add(user)
    db.session.commit()
    logout_user()
    return redirect(url_for('index_view'))

'''
Description: 404 Error handling
Input: None
Return Type: Error message
'''
@app.errorhandler(404)
def error_404(error=None):
    message = {
        'status': 404,
    }
    resp = jsonify(message)
    resp.status_code = 404
    return resp

'''
Description: 401 Error handling
Input: None
Return Type: Error message
'''
@app.errorhandler(401)
def error_401(errCode, msg):
    message = {
        'status': 401,
        'errCode': errCode,
        'reason': msg
    }
    resp = jsonify(message)
    resp.status_code = 401
    return resp

'''
Description: SocketIO connect event method for browser clients
Input: None
Return Type: Prints statement on server side when client connects
'''
@socketio.on('connect')
def browser_socketio_connect():
    print('BlueHat browser client connected!')

'''
Description: SocketIO disconnect event method for browser clients
Input: None
Return Type: Prints statement on server side when client disconnects
'''
@socketio.on('disconnect')
def browser_socketio_disconnect():
    print('BlueHat browser client disconnected!')

'''
Description: SocketIO register observer event method for browser clients
Input: Observer Device data to register itself
Return Type: None
'''
@socketio.on('register_observer')
def browser_socketio_registerObserver(data):
    print(data)
    deviceId = data['observerId']
    locationName = data['location']
    xCoord = int(data['xCoord'])
    yCoord = int(data['yCoord'])
    newObserver = Central(device_UUID=deviceId, locationName=locationName, xCoord=xCoord, yCoord=yCoord)
    db.session.add(newObserver)
    db.session.commit()

'''
Description: SocketIO register advertiser event method for browser clients
Input: Advertiser Device data to register itself
Return Type: None
'''
@socketio.on('register_advertiser')
def browser_socketio_registerAdvertiser(data):
    print(data)
    deviceId = data['advertiserId']
    user = Users.query.filter_by(email=data['advertiserEmail']).first()
    newAdvertiser = Peripheral(device_UUID=deviceId, user_id=user.id)
    db.session.add(newAdvertiser)
    db.session.commit()
    redis.sadd(deviceId, data['advertiserName'])

'''
Description: SocketIO connect event method for Observer clients
Input: None
Return Type: Prints statement on server side when client connects
'''
@socketio.on('connect', namespace='/observer')
def observer_socketio_connect():
    print('BlueHat Observer Device connected!')

'''
Description: SocketIO discconect event method for any client
Input: None
Return Type: Prints statement on server side when client disconnects
'''
@socketio.on('disconnect', namespace='/observer')
def socketio_disconnect():
    print('BlueHat Observer Device disconnected!')

'''
Description: SocketIO event method that handles messages sent BlueHat Observer devices
Input: None
Return Type: None
'''
@socketio.on('observer_json_msg', namespace='/observer')
def handleObserverMessage(json_data):
    json_data = json.loads(json_data)
    for reading in json_data:
        reading = Box(reading)
        # observerKalmanIdx = int(reading.ObserverID)
        # advertiserKalmanIdx = 0
        filteredRSSI = 0
        print reading.DeviceID
        if reading.DeviceID is 'aaaaaaaa':
            print 'boo'
        elif reading.DeviceID == 'bbbbbbbb':
            filteredRSSI = kalmanFilterB1.filter(reading.RSSI)
        elif reading.DeviceID == 'cccccccc':
            filteredRSSI = kalmanFilterC1.filter(reading.RSSI)
        distance = int(calcDistanceFris(filteredRSSI))
        print ('%s, %d, %d, %d') % (reading.DeviceID, filteredRSSI, reading.RSSI, distance)
        # distance = calcDistancePowerFit(filteredRSSI)
        redis.zadd(reading.DeviceID, distance, reading.ObserverID)
    timeNow = int(time.time())
    timeDelta = timeNow - timePrev
    if timePrev is 0 or timeDelta > 1:
        json_list = []
        json_data = {}
        for DeviceID in DeviceID_List:
            data = redis.zrange(DeviceID, 0, 2, withscores=True)
            if len(data) > 2:
                centralA = getObserverCoords(data[0][0])
                distA = data[0][1]
                centralB = getObserverCoords(data[1][0])
                distB = data[1][1]
                centralC = getObserverCoords(data[2][0])
                distC = data[2][1]
                location = estimateLocation(centralA, centralB, centralC, distA, distB, distC)
                json_data = {
                    'deviceID': DeviceID,
                    'xCoord': location[0],
                    'yCoord': location[1]
                }
                json_list.append(json_data)
            socketio.emit('hardhat_position', json_data)

def getObserverCoords(observerID):
    if observerID == '1':
        return ObserverLocation[0]
    elif observerID == '2':
        return ObserverLocation[0]
    elif observerID == '3':
        return ObserverLocation[0]
    elif observerID == '4':
        return ObserverLocation[0]

def calcDistanceFris(filteredRSSI):
    pathLoss = 2
    if filteredRSSI < -64.6:
        pathLoss = 2.2
    rssiDelta = rssi_ref - filteredRSSI
    fraction = rssiDelta / (10 * pathLoss)
    return math.pow(10, fraction)

def calcDistancePowerFit(filteredRSSI):
    multiplier = 0.8038093
    power = 11.5906746
    intercept = 0.5299515
    ratio = filteredRSSI / rssi_ref
    dist = (multiplier * math.pow(ratio, power)) + intercept
    return dist

# Return the distance between two given points
# Points are given by coordinates as tuples, i.e.(x,y)
def distance(point1, point2):
    return math.sqrt((point2[0]-point1[0])**2 + (point2[1]-point1[1])**2)

# Helper function of calculating the Intersection for CASE3 which
# is the general case that two circles have intersections
def getGeneralIntersect(circleA, circleB, toCompare, dist1, dist2):
    dSqr = ((circleB[0]-circleA[0])**2 + (circleB[1]-circleA[1])**2)
    K = (0.25) * (math.sqrt(((dist1+dist2)**2 - dSqr) * (dSqr - (dist1-dist2)**2)))

    x1 = ((0.5)*(circleB[0] + circleA[0]) + (1/2)*(circleB[0] - circleA[0])*(dist1**2 - dist2**2)/dSqr) + (2*(circleB[1]-circleA[1])*K/dSqr)
    x2 = ((0.5)*(circleB[0] + circleA[0]) + (1/2)*(circleB[0] - circleA[0])*(dist1**2 - dist2**2)/dSqr) - (2*(circleB[1]-circleA[1])*K/dSqr)
    y1 = ((0.5)*(circleB[1] + circleA[1]) + (1/2)*(circleB[1] - circleA[1])*(dist1**2 - dist2**2)/dSqr) - (2*(circleB[0]-circleA[0])*K/dSqr)
    y2 = ((0.5)*(circleB[1] + circleA[1]) + (1/2)*(circleB[1] - circleA[1])*(dist1**2 - dist2**2)/dSqr) + (2*(circleB[0]-circleA[0])*K/dSqr)

    point1 = (x1, y1)
    point2 = (x2, y2)

    # pick the point that closer to the third point
    if(distance(point1, toCompare) <= distance(point2, toCompare)):
        return point1
    else:
        return point2

# Get the intersections given two centrals and distances
# Return the intersection by coordinate as tuples, i.e.(x,y)
def getIntersect(center1, center2, centerToCompare, dist1, dist2):
    # CASE 1: if one circle is inside the other
    if(dist1 > distance(center1, center2) + dist2):
        while(dist1 > distance(center1, center2) + dist2):
            dist2 += 1
        return getGeneralCaseIntersect(center2, center1, centerToCompare, dist1, dist2)
    elif(dist2 > distance(center1, center2) + dist1):
        while(dist2 > distance(center1, center2) + dist1):
            dist1 += 1
    # CASE 2: if two circles are independent
    elif(distance(center1, center2) > (dist1 + dist2)):
        while(distance(center1, center2) > (dist1 + dist2)):
            dist1 += 1
            dist2 += 1
    # CASE 3: else the general case that two circles have intersections
    return getGeneralIntersect(center1, center2, centerToCompare, dist1, dist2)

# Get the estimated location given the centrals and distances
# First estimate the region that peripherial device can be contained
# then return the center of that region by coordinates as tuples
def estimateLocation(centralA, centralB, centralC, distA, distB, distC):
    p1 = getIntersect(centralA, centralB, centralC, distA, distB)
    p2 = getIntersect(centralB, centralC, centralA, distB, distC)
    p3 = getIntersect(centralC, centralA, centralB, distC, distA)

    # Check if points are the same
    if(p1 == p2 and p2 == p3):
        return p1
    elif(p1 == p2 or p3 == p2):
        return ((p1[0]+p3[0])/2, (p1[1]+p3[1])/2)
    elif(p1 == p3):
        return ((p1[0]+p2[0])/2, (p1[1]+p2[1])/2)
    else:
        return ((p1[0]+p2[0]+p3[0])/3, (p1[1]+p2[1]+p3[1])/3)
